import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

"""
以下のようなデータフレームdfがある。
このデータフレームから、A列とB列の値が3000のデータフレームを抽出するコードとして
正しいものを選べ。
"""

df = pd.DataFrame({"A": [10, 200, 3000, 40000], "B": [1000, 2000, 3000, 4000]})

result = df[(df["A"] == 3000) & (df["B"] == 3000)]
print(result)

"""
実行結果
      A     B
2  3000  3000
"""
print(end="\n\n")

"""
面積を昇順で並び変えたdfにする方法を
以下から選べ
"""

df = pd.DataFrame(
    {
        "国名": ["日本", "アメリカ", "中国", "イタリア", "フランス", "ロシア", "ブラジル", "イギリス"],
        "面積": [380000, 9834000, 959700, 301300, 643800, 17100000, 8516000, 242500],
    }
)

result = df.sort_values("面積")
# デフォルトは昇順、降順にする場合は、引数にascending=Falseとする
print(result)

print(end="\n\n")

"""
以下のコードを実行した場合に
xxに格納されるデータとして正しいものを選べ
"""
m = np.arange(4)
n = np.arange(4)
xx, yy = np.meshgrid(m, n)
print(xx, end="\n")

"""
実行結果
[[0 1 2 3]
 [0 1 2 3]
 [0 1 2 3]
 [0 1 2 3]]

meshgridは引数を元に格子座標を生成します。\
補足としてyyはarray([[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]])になります。
"""
print(end="\n\n")

"""
以下のコードを実行した場合の出力として、正しいものを選べ。
"""

A = np.array([[0, 1, 2, 3, 4]])
B = np.full((1, 5), 1)
result = A[A >= B]
print(result)

"""
実行結果
[1 2 3 4]
"""
print(end="\n\n")

"""
以下のようなデータフレームdfがある。
このデータフレームから、B列の値が3000以上のデータフレームを抽出するコードとして正しいものを選べ。
"""
df = pd.DataFrame({"A": [10, 200, 3000, 40000], "B": [1000, 2000, 3000, 4000]})
result = df[df["B"] >= 3000]
print(result)
"""
実行結果
       A     B
2   3000  3000
3  40000  4000
"""

print(end="\n\n")

"""
以下のコードの後に、np.dot(a, b)を実行した場合の出力と同じにならないものを選べ
"""
a = np.array([[0, 1, 10], [0, 1, 10]])
b = a.copy()
a = a.reshape(3, 2)
print("np.dot(a, b) : \n", np.dot(a, b))
print("a.dot(b) : \n", a.dot(b))
print("a @ b : \n", a @ b)
print("np.matmul(a, b) : \n", np.matmul(a, b))
"""
実行結果
np.dot(a, b) :
 [[  0   1  10]
 [  0  10 100]
 [  0  11 110]]
a.dot(b) :
 [[  0   1  10]
 [  0  10 100]
 [  0  11 110]]
a @ b :
 [[  0   1  10]
 [  0  10 100]
 [  0  11 110]]
np.matmul(a, b) :
 [[  0   1  10]
 [  0  10 100]
 [  0  11 110]]

dot、@、matmulは全て行列積のメソッド
"""

print(end="\n\n")

"""
以下のような、ユーザーごとのサービス利用状況が格納されたデータフレームdfがある。
サービス利用料金ごとの人数をヒストグラムで表示するためのコードとして正しいものを選べ
"""
df = pd.DataFrame(
    {
        "ユーザーID": [0, 1, 2, 3, 4],
        "利用回数": [79.0, 78.0, 33.0, 55.0, 52.0],
        "利用料金": [4667.0, 5041.0, 8631.0, 8750.0, None],
        "性別": ["男性", "男性", "女性", "女性", "男性"],
        "既婚/独身": ["既婚", "独身", "既婚", "既婚", "既婚"],
    }
)

df["利用料金"].hist()
plt.show()
"""
実行結果
※描画図参照
"""

print(end="\n\n")

"""
正規分布に従う乱数を生成するNumPyのメソッドとして、正しいものを選べ
"""
result = np.random.randn()
print(result)
"""
実行結果
-0.5485590111861378
"""

print(end="\n\n")

"""
dfと名付けられている、以下のようなデータフレームがある。
このデータフレームから、人口/万人カラムを削除する場合のコードとして正しいものを選べ
"""
df = pd.DataFrame(
    {
        "国名": ["日本", "アメリカ", "イタリア", "フランス", "ロシア", "ブラジル", "イギリス"],
        "人口/万人": [12700, 32800, 6000, 6700, 14500, 20900, 6600],
    }
)
print(df)
print(df.drop("人口/万人", axis=1))  # 列を削除したいので axis=1
"""
実行結果
◆実行前
     国名  人口/万人
0    日本  12700
1  アメリカ  32800
2  イタリア   6000
3  フランス   6700
4   ロシア  14500
5  ブラジル  20900
6  イギリス   6600

◆実行後
     国名
0    日本
1  アメリカ
2  イタリア
3  フランス
4   ロシア
5  ブラジル
6  イギリス
"""

print(end="\n\n")

"""
以下のような、ユーザーごとのサービス利用状況が格納されたデータフレームdfがある。
カラムごとの欠損値の割合を円グラフとして可視化するコードとして正しいものを選べ
"""
df = pd.DataFrame(
    {
        "ユーザーID": [0, 1, 2, 3, 4],
        "利用回数": [79.0, 78.0, 33.0, 55.0, 52.0],
        "利用料金": [4667.0, 5041.0, 8631.0, 8750.0, None],
        "性別": ["男性", "男性", "女性", "女性", "男性"],
        "既婚/独身": ["既婚", "独身", "既婚", "既婚", "既婚"],
    }
)

plt.pie(df.isnull().sum(), labels=df.columns, autopct="%1.1f%%")
plt.show()
"""
df.isnull().sum()を実行すると欠損値が含まれる行数の合計が返されます。
その合計をデータの数で割ると欠損値が含まれる割合が返されます。
"""

print(end="\n\n")

"""
以下のコードを実行した場合の出力として、正しいものを選べ。
"""
A = np.array([[1, 3, 5]])
B = np.array([[6, 8, 10]])
C = np.concatenate([A, B], axis=0)
D = np.diff(C, axis=0)
np.sum(D)
print("C : \n", C)
print("D : \n", D)
print("np.sum(D) : ", np.sum(D))
"""
実行結果
C : 
 [[ 1  3  5]
 [ 6  8 10]]
 D :
 [[5 5 5]]
 np.sum(D) :  15
"""

"""
以下のpandasデータフレームdfのDateカラムはオブジェクト型である。
このDateカラムをdatetime型に変換するコードとして正しいものを以下の中から選べ
"""
df = pd.DataFrame(
    {
        "日付": ["2000/3/27", "2000/3/28", "2000/3/29", "2000/3/30", "2000/3/31"],
        "始値": [19976.14063, 20273.67969, 20406.56055, 20706.44922, 20371.07031],
        "終値": [20281.02930, 20374.33984, 20706.65039, 20441.50000, 20337.32031],
    }
)
print("実行前:\n", df)
df["日付"] = pd.to_datetime(df["日付"])
print("実行後:\n", df)
"""
実行結果
pandas datetime型に変換するメソッドは to_datetime()メソッドです。
実行前:
           日付           始値           終値
0  2000/3/27  19976.14063  20281.02930
1  2000/3/28  20273.67969  20374.33984
2  2000/3/29  20406.56055  20706.65039
3  2000/3/30  20706.44922  20441.50000
4  2000/3/31  20371.07031  20337.32031

実行後:
           日付           始値           終値
0 2000-03-27  19976.14063  20281.02930
1 2000-03-28  20273.67969  20374.33984
2 2000-03-29  20406.56055  20706.65039
3 2000-03-30  20706.44922  20441.50000
4 2000-03-31  20371.07031  20337.32031
"""

print(end="\n\n")

"""
以下のような日付ごとの利用回数と利用料金が格納された
pandasデータフレームdfがある。
このデータフレームdfの中から利用回数が最大のレコードを抽出するコードとして正しいものを選べ
"""
df = pd.DataFrame(
    {
        "日付": [
            "2020-01-01",
            "2020-01-02",
            "2020-01-03",
            "2020-01-04",
            "2020-01-05",
            "2020-01-06",
            "2020-01-07",
            "2020-01-08",
            "2020-01-09",
            "2020-01-10",
        ],
        "利用回数": [79.0, 78.0, 33.0, 55.0, None, None, 26.0, 97.0, 59.0, 34.0],
        "利用料金": [
            4667.0,
            5041.0,
            8631.0,
            8750.0,
            None,
            None,
            9329.0,
            5582.0,
            2450.0,
            1140.0,
        ],
    }
)
print(df[df["利用回数"] == df["利用回数"].max()])
"""
実行結果
           日付  利用回数    利用料金
7  2020-01-08  97.0  5582.0
"""
